**Frontend**
- Parallelized consecutive independent calls to the backend: previously, the api calls would execute in sequence, which meant that call 1 had to end before call 2 could start. By executing the calls in parallel using JavaScript’s Promise.all(), we got a significant speedup (Kiron)
- Consolidated all functions that make backend api calls in a single file: previously, we had these functions spread out across several components, but this made the component files bloated. We also had duplicate functions as a result because whenever we needed a  new api helper function, we had to scan the entire codebase to check if it was already defined. After the refactor, all api helper functions are in a file api.js: a developer can simply look at this single file to see how the frontend interacts with the backend and to check if a given helper function for an endpoint already exists. (Kiron)
- Added more comments: initially we had practically no comments since we were working on the app collaboratively in person and knew the changes other team members made. As time went on and we kept adding more features independently, it was often confusing to read and understand what others did. So, we decided to add comments to make the code more readable (Kiron)
  - Added more comments for all of the UI colorings, as hex code colors are unreadable (Peter)
- Used stylesheets to remove css from the component body: previously, we had in-line styling but this added several lines of code to each component. We decided to extract all styling into stylesheets to decouple the styling of a component from its logic. This made our code more readable (Kiron)
- Made use of helper functions for page navigation - previously we had simply recreated the logic repeatedly, rather than creating a set method of navigating from one page to another. By standardizing the function, we were able to use the logic in multiple situations without recreating the functions. (Sambhav)
- Good naming strategies - we followed good naming strategies for the components as well as the variables and the functions that we used to make them as clear as possible to the developers. Certain initial design decisions made it confusing when you were navigating between components and props. (Sambhav)
- Consistent Error Handling - Made sure that error handling is consistent, with user-friendly error messages that do not break the user experience. We initially had app-breaking errors which are now handled with correct messages. (Peter)
- Added Documentation - Added a step by step instruction to how to install all dependencies and run the application. (Darren)
- To keep related classes together and make the code easy to follow, I created folders and put together pages in the same navigation stacks such as Settings screens and calendar screens. This allows anyone reading the codes to find classes representing pages that are related very easily. (Fabrice)

**Backend/Database**
- In staying consistent with the concept of low coupling, the goal with the backend was to ensure the frontend application would only need to interact with application logic via the Python API. This also meant that all database accesses also came from the Python backend server. (Ishan)
- From the beginning, good refactoring was a goal in backend development, making sure that all files were strongly cohesive (each one would only focus on one area). In practice, this meant that there were separate files for handling users, connections, workouts, and so on. (Ishan)
  - Further refactoring was used in that for each of these areas (ex. connections, workouts), there were actually two files. One file included definitions for all the API endpoints, and the other one handled database access and pure Python implementations of application logic (such as parsing user profile data). The idea here was that when HTTP requests were made, control to provide the requested resource or action was handed over to a separate function. This made debugging easier, and having simply named files that corresponded in resources and databases folders made the entire server codebase easier to understand and read. (Ishan)
  - This codebase structure allowed the application to be in line with the single responsibility principle. It also followed the open-closed principle, allowing for additional functionality features to be added easily in the appropriate file, and adding new features was simple as well. (Ishan)
- Some server functions (especially non-CRUD functionality like recommendations) are more computationally intensive, so they resulted in relatively high latency for API requests. Since these computations were largely sequential and not being cached, there was significant room for speedup here. (Ishan)
  - In the case of connection recommendations, the fix was twofold: introducing a caching layer as well as multithreading to make some of the computation asynchronous. A new table was created in the database to store a list of recommendations for each user, and whenever recommendations were requested, a list had already been generated recently (threshold of 7 days), then that could be provided back right away, avoiding the expensive recomputation. (Ishan)
  - When there were no recommendations cached (or they were outdated), only some of the computation would be done synchronously, and the more time-consuming parts were delegated to a separate thread that could operate in the background and update the cached recommendations list without blocking the response back to the requester. This essentially prioritized availability over immediate consistency (eventual consistency was adequate here), and providing SOME recommendations faster was more important than providing all the recommendations but with unreasonable latency. (Ishan)
- In implementations of more complex application logic, some of the functions got somewhat longer. In these cases, helper functions were written to remove the heavy-lifting from the higher-level functions. These helper functions were moved to the bottom of files and labeled as such. (Ishan)
  - There were a few situations where trying to make longer functions into smaller functions would have hurt readability and ability to understand what was happening. In these cases, the long functions were left, and instead descriptive comments were added to delineate what was happening in different parts of a function. (Ishan)
- The backend server would be useless if it wasn’t easy to interface with by the frontend (or any other client). Therefore, endpoint documentation was a priority throughout, and this was maintained in a README.md file in the backend directory. All endpoints were maintained here, with sample request/response schemas wherever appropriate. (Ishan)
- The Postgres database (on supabase), was handled fairly intuitively. Each class (like a Users or Workouts) corresponded directly to a table in the database. Once again, this aided in making the connection between endpoints, application logic, and database very clear and easy to debug and understand. (Ishan)
- Naming was also, in general, fairly intuitive. There were a few cases where some variables were named a little poorly, and some function names were very similar, which could lead to confusion. This was rectified during our code review, renaming functions and variables as needed. (Ishan)
